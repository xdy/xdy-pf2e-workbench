/// <reference types="jquery" resolution-mode="require"/>
import { ActorPF2e, type PartyPF2e } from "@actor";
import { HitPointsSummary } from "@actor/base.ts";
import { CreatureSource } from "@actor/data/index.ts";
import { StatisticModifier } from "@actor/modifiers.ts";
import { MovementType, SaveType, SkillLongForm } from "@actor/types.ts";
import { ArmorPF2e, ItemPF2e, PhysicalItemPF2e } from "@item";
import { ItemType } from "@item/data/index.ts";
import { ItemCarryType } from "@item/physical/data.ts";
import { ActiveEffectPF2e } from "@module/active-effect.ts";
import { Rarity } from "@module/data.ts";
import { RuleElementSynthetics } from "@module/rules/index.ts";
import { UserPF2e } from "@module/user/index.ts";
import type { TokenDocumentPF2e } from "@scene/index.ts";
import type { CheckRoll } from "@system/check/index.ts";
import type { ArmorStatistic } from "@system/statistic/armor-class.ts";
import { Statistic, StatisticDifficultyClass } from "@system/statistic/index.ts";
import { CreatureSkills, CreatureSpeeds, CreatureSystemData, LabeledSpeed, SenseData, VisionLevel } from "./data.ts";
import { CreatureSensePF2e } from "./sense.ts";
import { Alignment, CreatureTrait, CreatureUpdateContext, GetReachParameters } from "./types.ts";
/** An "actor" in a Pathfinder sense rather than a Foundry one: all should contain attributes and abilities */
declare abstract class CreaturePF2e<TParent extends TokenDocumentPF2e | null = TokenDocumentPF2e | null> extends ActorPF2e<TParent> {
    parties: Set<PartyPF2e>;
    /** A creature always has an AC */
    armorClass: StatisticDifficultyClass<ArmorStatistic>;
    /** Skill checks for the creature, built during data prep */
    skills: CreatureSkills;
    /** Saving throw rolls for the creature, built during data prep */
    saves: Record<SaveType, Statistic>;
    perception: Statistic;
    /** The creature's position on the alignment axes */
    get alignment(): Alignment;
    get rarity(): Rarity;
    get allowedItemTypes(): (ItemType | "physical")[];
    /**
     * A currently naive measurement of this creature's reach
     * @param [context.action] The action context of the reach measurement. Interact actions don't consider weapons.
     * @param [context.weapon] The "weapon," literal or otherwise, used in an attack-reach measurement
     */
    getReach({ action, weapon }?: GetReachParameters): number;
    get visionLevel(): VisionLevel;
    get hasDarkvision(): boolean;
    get hasLowLightVision(): boolean;
    get canSee(): boolean;
    get canAct(): boolean;
    get canAttack(): boolean;
    get isDead(): boolean;
    /** Whether the creature emits sound: overridable by AE-like */
    get emitsSound(): boolean;
    get isSpellcaster(): boolean;
    get wornArmor(): ArmorPF2e<this> | null;
    /** Get the held shield of most use to the wielder */
    get heldShield(): ArmorPF2e<this> | null;
    /** Retrieve percpetion and spellcasting statistics */
    getStatistic(slug: SaveType | SkillLongForm | "perception"): Statistic;
    getStatistic(slug: string): Statistic | null;
    protected _initialize(options?: Record<string, unknown>): void;
    prepareData(): void;
    /** Setup base ephemeral data to be modified by active effects and derived-data preparation */
    prepareBaseData(): void;
    prepareEmbeddedDocuments(): void;
    prepareDerivedData(): void;
    protected prepareSynthetics(): void;
    /**
     * Changes the carry type of an item (held/worn/stowed/etc) and/or regrips/reslots
     * @param item       The item
     * @param carryType  Location to be set to
     * @param handsHeld  Number of hands being held
     * @param inSlot     Whether the item is in the slot or not. Equivilent to "equipped" previously
     */
    adjustCarryType(item: PhysicalItemPF2e<CreaturePF2e>, { carryType, handsHeld, inSlot, }: {
        carryType: ItemCarryType;
        handsHeld?: number;
        inSlot?: boolean;
    }): Promise<void>;
    /**
     * Adds a custom modifier that will be included when determining the final value of a stat. The slug generated by
     * the name parameter must be unique for the custom modifiers for the specified stat, or it will be ignored.
     */
    addCustomModifier(stat: string, label: string, value: number, type: string): Promise<void>;
    /** Removes a custom modifier by slug */
    removeCustomModifier(stat: string, slug: string): Promise<void>;
    /**
     * Roll a Recovery Check
     * Prompt the user for input regarding Advantage/Disadvantage and any Situational Bonus
     */
    rollRecovery(event: JQuery.TriggeredEvent): Promise<Rolled<CheckRoll> | null>;
    /** Prepare derived creature senses from Rules Element synthetics */
    prepareSenses(data: SenseData[], synthetics: RuleElementSynthetics): CreatureSensePF2e[];
    prepareSpeed(movementType: "land"): this["system"]["attributes"]["speed"];
    prepareSpeed(movementType: Exclude<MovementType, "land">): (LabeledSpeed & StatisticModifier) | null;
    prepareSpeed(movementType: MovementType): CreatureSpeeds | (LabeledSpeed & StatisticModifier) | null;
    /** Remove any features linked to a to-be-deleted ABC item */
    deleteEmbeddedDocuments(embeddedName: "ActiveEffect" | "Item", ids: string[], context?: DocumentModificationContext<this>): Promise<ActiveEffectPF2e<this>[] | ItemPF2e<this>[]>;
    protected _preUpdate(changed: DeepPartial<this["_source"]>, options: CreatureUpdateContext<TParent>, user: UserPF2e): Promise<boolean | void>;
    /** Overriden to notify the party that an update is required */
    protected _onDelete(options: DocumentModificationContext<TParent>, userId: string): void;
}
interface CreaturePF2e<TParent extends TokenDocumentPF2e | null = TokenDocumentPF2e | null> extends ActorPF2e<TParent> {
    readonly _source: CreatureSource;
    system: CreatureSystemData;
    get traits(): Set<CreatureTrait>;
    get hitPoints(): HitPointsSummary;
    /** Expand DocumentModificationContext for creatures */
    update(data: DocumentUpdateData<this>, options?: CreatureUpdateContext<TParent>): Promise<this>;
    /** See implementation in class */
    updateEmbeddedDocuments(embeddedName: "ActiveEffect", updateData: EmbeddedDocumentUpdateData<ActiveEffectPF2e<this>>[], options?: DocumentUpdateContext<this>): Promise<ActiveEffectPF2e<this>[]>;
    updateEmbeddedDocuments(embeddedName: "Item", updateData: EmbeddedDocumentUpdateData<ItemPF2e<this>>[], options?: DocumentUpdateContext<this>): Promise<ItemPF2e<this>[]>;
    updateEmbeddedDocuments(embeddedName: "ActiveEffect" | "Item", updateData: EmbeddedDocumentUpdateData<ActiveEffectPF2e<this> | ItemPF2e<this>>[], options?: DocumentUpdateContext<this>): Promise<ActiveEffectPF2e<this>[] | ItemPF2e<this>[]>;
    deleteEmbeddedDocuments(embeddedName: "ActiveEffect", ids: string[], context?: DocumentModificationContext<this>): Promise<ActiveEffectPF2e<this>[]>;
    deleteEmbeddedDocuments(embeddedName: "Item", ids: string[], context?: DocumentModificationContext<this>): Promise<ItemPF2e<this>[]>;
    deleteEmbeddedDocuments(embeddedName: "ActiveEffect" | "Item", ids: string[], context?: DocumentModificationContext<this>): Promise<ActiveEffectPF2e<this>[] | ItemPF2e<this>[]>;
}
export { CreaturePF2e };
